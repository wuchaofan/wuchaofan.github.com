<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width">
	<title>Home</title>
	<link rel="stylesheet" type="text/css" href="stylesheets/materialize.min.css">
	<script type="text/javascript" src="g/bridge/jquery.2.0.0.min.js"></script>
	<script type="text/javascript" src="javascripts/materialize.min.js"></script>
	<link rel="stylesheet" type="text/css" href="stylesheets/home.css">

</head>
<body>
<div class="side-nav-button">
	<a href="#" class="sidebar-nav">
		<img src="images/bar.png">
	</a>
</div>
<div class="side-bar">
	<div class="user-cl">
		<img src="images/user.png">
	</div>
	<div>
		<ul class="left-ul">
			<li>自制Docker</li>
			<li>
				<a href="study.html">随笔记录</a>
			</li>
			<li>2015/9/26</li>
			<li>关于</li>
		</ul>
	</div>
</div>
<div class="home">
  <div class="parallax-container">
    <div class="parallax"><img src="images/d3.jpg"></div>
  	<p class="p-title">自制Docker</p>
  </div>
  <div class="container">
  	<div class="row">
  		<div class="col s12 m12 l12">
  		<p class="section-title">1、独立的文件系统【文件系统隔离】</p>
  		<p>由于Docker的大热，驱使着本人也随波逐流的学习一番。本篇更准确的来说是模仿docker做一个容器。如果你了解LXC或者制作过 <a href="http://www.linuxfromscratch.org/lfs/view/stable/index.html" target="_blank">LFS</a>，实现一个容器就容易多了。经过一番研究，我们知道docker是容器，轻量级的vm，事实上它是在一个操作系统上实现的网络隔离、存储隔离，docker主要用到了三方面的技术。我们可以通过一下三点对应，并用这三点实现docker</p>
			<ul>
				<li>linux的chroot，指定根目录——实现存储隔离</li>
				<li>linux内核的net namespace，利用ip命令——网络隔离</li>
				<li>版本控制，记录每次修改——定制系统</li>
			</ul>
			<p>下文本人利用chroot、ip命令实现一个简易的docker，版本控制我们可以使用git。
			我们知道可以利用chroot切换到指定的目录作为根目录。
			</p>
				<code>sudo chroot /path/to</code> 或者 <code>sudo chroot /path/to /bin/bash</code>
				<p>上面两条命令作用是一样的，目的就是把 <span>/path/to</span>作为根目录，然后执行 <span>/path/to/bin/bash</span> 路径下的bash。此时 <span>/path/to</span> 与linux的根目录 <span>/</span> 一样。</p>
				<p>
					但是即使你在<span>/path/to</span>创建bin文件夹，并把bash (我们可以通过<code>which bash</code>查看bash的路径，一般都会在/bin下) 拷贝到 <span>/path/to/bin</span>，此时bash并不能运行。为什么呢？这就要说一个程序运行和文件系统的作用了。
					我们知道程序的运行需要依赖动态连接库，没有这些库bash是不能够运行的。我们可以用ldd查看：

				</p>
				<pre><code>$ <span>ldd /bin/bash</span>
	linux-vdso.so.1 =>  (0x00007fff1c1e0000)
	libtinfo.so.5 => /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f78b2090000)
	libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f78b1e8c000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f78b1ac7000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f78b22c1000)</code>
				</pre>
				<p>
					上面实在ubuntu 14.04系统中查看的信息，所以bash依赖库就在/lib和/lib64下面，那么我们就必须在<span>/path/to</span>目录下创建lib及lib64目录，并把依赖库拷贝进去。这样我们就可以使用chroot命令，效果如下：
				</p>
				<pre><code>$ <span>sudo chroot /path/to /bin/bash</span>
	bash-4.3#
	bash-4.3#
	bash-4.3# pwd
	/
	bash-4.3#</code></pre>
				<p>由于这里也用到了pwd命令，所以也要解决pwd的依赖关系。我们可以直接把系统/lib、/lib64直接拷贝到<span>/path/to/lib</span>、<span>/path/to/lib64</span>。从pwd输出我们知道此时的根目录已经变了，即 <span>/path/to</span> 作为根目录。到此就实现了文件系统的隔离。我们想要更好的开发和使用我们就需要一个相对标准的文件系统。如下样子：</p>
				<pre><code>$ <span>ls /</span>
	bin   dev  home        lib    lost+found  mnt  proc  run   srv  tmp  var
	boot  etc  initrd.img  lib64  media       opt  root  sbin  sys  usr  vmlinuz
				</code></pre>
				<p>当然我们并不需要所有的这些文件夹及其里面的文件，比如仅仅想跑python的程序，那么我们可以对其裁剪，满足Python及程序的依赖就可以了。当然后续的PATH、SP1等环境变量可能也许设置。</p>
				<p>
					这仅仅是对文件系统的隔离，如果要让程序跑在像是独立的系统里，我们还需要网络隔离。这就需要强大的ip命令。

				</p>
		</div>
  		
  	</div>
  	<div class="row">
  		<div class="col s12 m12 l12">
			<p class="section-title">2、独立的网络【网络隔离】</p>
  		</div>
  	</div>
  </div>
</div>
  <script type="text/javascript">
  $(function(){
  	$('.parallax').parallax();
  	$(".button-collapse").sideNav();

  	$('.sidebar-nav').click(function(){
  		if($(this).hasClass('sidebar-nav-move')){
	  		$(this).removeClass('sidebar-nav-move');
	  		$('.side-bar').removeClass('side-bar-show');

  		}else{
	  		$(this).addClass('sidebar-nav-move');
	  		$('.side-bar').addClass('side-bar-show');
	  	}
  		// $('.home').addClass('home-side');
  	})
  })
  </script>
</body>
</html>